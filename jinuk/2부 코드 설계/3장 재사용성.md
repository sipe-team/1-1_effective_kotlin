# 3장 재사용성
## 19. knowledge를 반복하여 사용하지 말라
- DRY 규칙 - Don't Repeat Yourself
  - WET 안티패턴, SSOT로도 알려짐
- knowledge - 의도적인 정보
  - logic - 프로그램의 동작 방식 - 시간에 따라 바뀜
  - common algorithm - 원하는 동작을 하기 위한 알고리즘 - 크게 변하지 않음
- 범용적인 로직의 경우 코드를 반복하지 않고, 재사용할 수 있어야 함
- 비슷해 보이지만, 실질적으로 다른 knowledge인 경우 추출하면 안 되는 부분도 있음
- 단일 책임 원칙
  - 서로 다른 곳에서 사용하는 knowledge는 독립적으로 변경할 가능성이 많으므로, 다른 knowledge로 취급하는 것이 좋음
  - 다른 knowledge는 분리해 두는 것이 좋음

## 20. 일반적인 알고리즘을 반복해서 구현하지 말라
- 이때 말하는 알고리즘은 비즈니스 로직이 아니라, 수학적 연산, 수집 처리 등 별도 라이브러리/모듈로 분리할 수 있는 부분
- 장점
  - 코드 작성 속도가 빨라짐
  - 함수 이름만 보고도 확실히 알 수 있음
  - 직접 구현 시 발생할 수 있는 실수를 줄일 수 있음
  - 제작자가 한번만 최적화하면, 모든 곳이 최적화 혜택을 받을 수 있음
- 특정 알고리즘의 경우 확장 함수로 정의하는 것이 좋음
  - 행위를 나타내기 좋음
  - 구체적 타입이 있는 객체에만 사용을 제한할 수 있음
  - 가독성이 좋아짐
  - 유틸리티의 위치를 찾을 필요가 없어지고, 자동 완성 기능 등으로 제안이 이루어짐

## 21. 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라
- 프로퍼티 위임이라는 기능을 제공
  - 일반적인 프로퍼티의 행위를 **추출**해서 재사용할 수 있음
  - ex) Lazy 프로퍼티로 패턴 구현 가능, observable 델리게이트 사용하여 구현 가능
- by 키워드를 이용하여 만든 객체를 정의한 클래스와 연결해 주는 방식으로 구현하여 사용
  - by의 경우, 컴파일된 상태를 보면 컨텍스트(this)와 프로퍼티 레퍼런스의 경계도 함께 사용하도록 변경됨
- 확장 함수 형태로도 만들 수 있음

## 22. 일반적인 알고리즘을 구현할 때 제네릭을 사용하라
- 타입 아규먼트를 사용하여 함수에 타입을 전달
  - 타입 아규먼트를 사용하는 함수를 제네릭 함수라고 부름
- 타입 파라미터를 통해 컴파일러가 타입을 더 정확하게 추측할 수 있게 해 줘서 프로그램이 안전해지고, 개발이 편해짐
- 특정 타입의 서브타입만 사용하도록 타입을 제한할 수도 있음

## 23. 타입 파라미터의 섀도잉을 피하라
- 프로퍼티와 파라미터가 같은 이름을 같은 경우, 지역 파라미터가 외부 스코프의 프로퍼티를 가릴 수 있음
  - 섀도잉이라고 부름
- 타입 파라미터가 섀도잉되는 상황을 의도하는 경우는 거의 없고, 독립적인 타입 파라미터를 의도했다면 아예이름을 다르게 달아서 명시적으로 보이는 것이 좋다

