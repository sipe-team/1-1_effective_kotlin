# 1장 안정성
## 1. 가변성을 제한하라
- 상태
  - 상태를 가질 수 있는 객체 - Mutable, var 등
    - 동기화 문제 가능성 있음
    - 코드 실행 추론이 어려움, 테스트하기 어려움
    - 가변성을 완전히 제한하기는 어렵지만, 신중하게 결정해야 함
  - 가변성 제한 객체 - Immutable, val, 읽기 전용 컬렉션, copy
    - val의 경우 mutable 객체를 담는다면 내부 값 변할 수 있으니 주의
      - 완전히 변경할 필요가 없다면 `final` 사용하기
    - 읽기 전용 컬렉션
      - 컬렉션 계층 중 다양한 읽기 전용 인터페이스 제공
      - 내부적으로 immutable하지 않은 컬렉션을 외부적으로 immutable하게 보이도록 만듦으로써 안정성 획득. 다운캐스팅 조심할 것
    - copy
      - immutable 객체의 경우 공유/복사 시에도 충돌이 이루어지지 않고, 캐싱도 가능
      - set/map의 키로 사용 가능
- 변경 가능 지점
  - 여러 선택지가 존재할 수 있음, 그러나 실제 이루어지는 처리 지점은 다를 수 있음
    - 변경 지점 관찰 가능 - 사용자 정의 세터 Or Delegate 이용
  - mutable 컬렉션 방식, var로 프로퍼티 읽고 쓸 수 있게 만들기 중 선택 - 둘다 사용하면 동기화를 두군데 다 구현해야 하고, 모호성 발생!
  - 변경 가능 지점은 노출하지 않는 것이 좋음
    - 방어적 복제
    - 읽기 전용 슈퍼타입으로 업캐스팅
- 하지만 항상 immutable이 좋은 것은 아니고, 효율성 때문에 Mutable이 좋을 때가 있음 - 성능이 중요한 부분에서만 사용, 멀티스레드에 주의

## 2. 변수의 스코프를 최소화하라
- 프로퍼티보다는 지역 변수 사용하는 것이 좋음
- 최대한 좁은 스코프를 갖게 변수 사용
  - 프로그램을 추적하고 관리하기 쉬워짐
  - 변수가 잘못 사용되는 경우를 줄일 수 있음
- 변수 정의할 때 초기화해주는 편이 좋음
  - if, when, try-catch, Elvis 표현식, 구조분해 선언 등
- 캡처링
  - 시퀀스 때문에 이해가 안가서 확인해 보니, yield 등 코루틴 용어가 많네요... 이건 코루틴 조금 이해하고 다시 보기
- 결론 - 스코프는 좁게 만들어 주는 것이 좋다.

## 3. 최대한 플랫폼 타입을 사용하지 말라
- 다른 언어에서 넘어온 타입을 플랫폼 타입이라고 부름(nullable, notnull 등을 보장할 수 없음)
- 가능하다면 외부 코드에 notnull이나 nullable 어노테이션을 붙여주는 편이 좋음
- 플랫폼 타입의 경우 값을 활용할 때 npe가 발생하기 때문에, 오류를 찾이 어려운 경향이 있음
- 결론 - 웬만하면 쓰지말자!

## 4. inferred 타입으로 리턴하지 말라
- 리턴 타입은 외부 사용자에게 전달할 수 있는 중요한 정보
- 명시적으로 지정해 주는 것이 좋음

## 5. 예외를 활용해 코드에 제한을 걸어라
- 코드의 동작이 명확하다면, 예외를 활용해서 제한을 걸어 주는 편이 좋음
  - require - 아규먼트 제한 - `IllegalArgumentException` 발생
  - check - 상태 동작 제한 - `IllegalStateException` 발생
  - assert - true check, 테스트 모드에서만 동작, 자체 점검용 - 애플리케이션 실행 시에는 예외x
  - return or throw와 함께 사용하는 Elvis 연산자 - nullable을 확인할 때 자주 사용되는 방법

## 6. 사용자 정의 오류보다는 표준 오류를 사용하라
- 직접 오류를 정의하는 것보다는 표준 라이브러리의 오류를 사용하는 것이 좋음
  - 널리 알려진 요소를 재사용함으로써 더 쉽게 배우고 이해할 수 있음

## 7. 결과 부족이 발생할 경우 null과 Failure를 사용하라
- 예외는 정보를 전달하는 방식으로 사용하면 안 됨, 예외는 잘못된 상황을 나타내야 함
- null - failure를 사용하면 예상되는 오류를 표현하기 편해짐
- 예외는 놓치는 경우가 생기거나, 전체 애플리케이션을 중지시킬 수 있기 때문에 유의 필요
- nullable을 리턴하지 말고, getOrNull등을 사용해서 리턴을 예측할 수 있도록 해줘야 함
  - (근데 getOrNull을 쓰면 결국 nullable한 객체가 리턴되는거 아닌가??? 잘모르겠음)