# 1장 안정성
## 1. 가변성을 제한하라
- 상태
  - 상태를 가질 수 있는 객체 - Mutable, var 등
    - 동기화 문제 가능성 있음
    - 코드 실행 추론이 어려움, 테스트하기 어려움
    - 가변성을 완전히 제한하기는 어렵지만, 신중하게 결정해야 함
  - 가변성 제한 객체 - Immutable, val, 읽기 전용 컬렉션, copy
    - val의 경우 mutable 객체를 담는다면 내부 값 변할 수 있으니 주의
      - 완전히 변경할 필요가 없다면 `final` 사용하기
    - 읽기 전용 컬렉션
      - 컬렉션 계층 중 다양한 읽기 전용 인터페이스 제공
      - 내부적으로 immutable하지 않은 컬렉션을 외부적으로 immutable하게 보이도록 만듦으로써 안정성 획득. 다운캐스팅 조심할 것
    - copy
      - immutable 객체의 경우 공유/복사 시에도 충돌이 이루어지지 않고, 캐싱도 가능
      - set/map의 키로 사용 가능
- 변경 가능 지점
  - 여러 선택지가 존재할 수 있음, 그러나 실제 이루어지는 처리 지점은 다를 수 있음
    - 변경 지점 관찰 가능 - 사용자 정의 세터 Or Delegate 이용
  - mutable 컬렉션 방식, var로 프로퍼티 읽고 쓸 수 있게 만들기 중 선택 - 둘다 사용하면 동기화를 두군데 다 구현해야 하고, 모호성 발생!
  - 변경 가능 지점은 노출하지 않는 것이 좋음
    - 방어적 복제
    - 읽기 전용 슈퍼타입으로 업캐스팅
- 하지만 항상 immutable이 좋은 것은 아니고, 효율성 때문에 Mutable이 좋을 때가 있음 - 성능이 중요한 부분에서만 사용, 멀티스레드에 주의
