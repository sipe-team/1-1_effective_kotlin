# 1장 안정성
## 1. 가변성을 제한하라
- 상태
  - 상태를 가질 수 있는 객체 - Mutable, var 등
    - 동기화 문제 가능성 있음
    - 코드 실행 추론이 어려움, 테스트하기 어려움
    - 가변성을 완전히 제한하기는 어렵지만, 신중하게 결정해야 함
  - 가변성 제한 객체 - Immutable, val, 읽기 전용 컬렉션, copy
    - val의 경우 mutable 객체를 담는다면 내부 값 변할 수 있으니 주의
      - 완전히 변경할 필요가 없다면 `final` 사용하기
    - 읽기 전용 컬렉션
      - 컬렉션 계층 중 다양한 읽기 전용 인터페이스 제공
      - 내부적으로 immutable하지 않은 컬렉션을 외부적으로 immutable하게 보이도록 만듦으로써 안정성 획득. 다운캐스팅 조심할 것
    - copy
      - immutable 객체의 경우 공유/복사 시에도 충돌이 이루어지지 않고, 캐싱도 가능
      - set/map의 키로 사용 가능
- 변경 가능 지점
  - 여러 선택지가 존재할 수 있음, 그러나 실제 이루어지는 처리 지점은 다를 수 있음
    - 변경 지점 관찰 가능 - 사용자 정의 세터 Or Delegate 이용
  - mutable 컬렉션 방식, var로 프로퍼티 읽고 쓸 수 있게 만들기 중 선택 - 둘다 사용하면 동기화를 두군데 다 구현해야 하고, 모호성 발생!
  - 변경 가능 지점은 노출하지 않는 것이 좋음
    - 방어적 복제
    - 읽기 전용 슈퍼타입으로 업캐스팅
- 하지만 항상 immutable이 좋은 것은 아니고, 효율성 때문에 Mutable이 좋을 때가 있음 - 성능이 중요한 부분에서만 사용, 멀티스레드에 주의

## 2. 변수의 스코프를 최소화하라
- 프로퍼티보다는 지역 변수 사용하는 것이 좋음
- 최대한 좁은 스코프를 갖게 변수 사용
  - 프로그램을 추적하고 관리하기 쉬워짐
  - 변수가 잘못 사용되는 경우를 줄일 수 있음
- 변수 정의할 때 초기화해주는 편이 좋음
  - if, when, try-catch, Elvis 표현식, 구조분해 선언 등
- 캡처링
  - 시퀀스 때문에 이해가 안가서 확인해 보니, yield 등 코루틴 용어가 많네요... 이건 코루틴 조금 이해하고 다시 보기
- 결론 - 스코프는 좁게 만들어 주는 것이 좋다.
