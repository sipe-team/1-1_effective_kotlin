## 안정성
* 가변성 제한
객체가 상태값을 가지고 있지 않도록 한다. 
val, mutable, copy 등 있음

### 하지 말아야 할 것
immutable을 mutable로 다운캐스팅 하는 것 -> mutable 컬렉션으로 새로 복제
세트, 맵 키에 mutable 사용 -> immutable 사용하고 자신 일부를 수정한 객체를 만들어 내도록 함(이걸 다하기 귀찮으니까 data class 는 copy를 제공함)
var + mutable 둘다 사용 -> 두 지점 모두 동기화 구현해야해서 제한
mutable을 다른 곳에서 노출 -> return 을 copy 로 하거나 immutable로 업캐스트
- - - -
* 변수 스코프 최소화
변경 추적, 이해도를 위해 변수 스코프 최소화
변수는 정의할 때 초기화 되는게 좋음
변수 캡처링 주의 - 최종값만 사용하는 문제
- - - -
* 플랫폼 타입 사용 지양
자바같은 경우 변수가 nullable임. 코틀린에서 바로 받아쓰면 플랫폼 타입이 되어 타입을 명시해주는게 안전함. (계속 nonnull 로 사용할 수 있고 혹시 null이 들어와도 타입 변경에서 바로 에러가 나서 발견하기 쉬움)
- - - -
* inferred 타입으로 리턴 금지
명시적으로 지정해야함
- - - -
* 예외로 코드에 제한걸기
require(argument 제한) - IllegalArgumentException
check(상태 관련 동작) - IllegalStateException
assert(true check, test) - 자기가 구현한 내용 확인할 때
- - - -
* 표준 오류 사용
이해도 높이기 위해 직접 오류 정의 보다는 표준 라이브러리에서 참조
- - - -
* 결과 부족 시에 null, Failure 사용
예외는 정보 전달용으로 사용 하지 않음, 예외적인 범위일때는 예외 throw
예상되는 오류 표현은 Null, + 추가적인 정보 전달은 Sealed class.
nullable 리턴 금지 널은 엘비스 연산자로 체크
- - - -
* 적절한 null 처리
	* ?., 스마트 캐스팅, 엘비스 연산자
	* error throw (throw, !!, requireNotNull, checkNotNull) 
		* !!은 제네릭 예외 발생, 미래에 nullable로 바뀔 수 있으므로 지양
	* non null type으로 변경
		* lateinit - 사용하기 전 초기화되는 변수 
		* 자바 기본 타입은 Delegates, notNull 사용 
		 `var doctorld: Int by Delegates.notNull()`
- - - -
* use를 사용하여 리소스 닫기
close로 닫아야 하는 리소스들은 GC가 돌아도 그때까지 유지하는 비용이 큼
보통 try catch로 finally에서 닫아주는데 예외가 생겼을때 스킵되는걸 방지해주는 함수가 use 메서드. try 문 안의 내용만 use 람다에 넣어주면된다. 파일은 useLinse로 한줄씩 처리
- - - -
* 단위 테스트 만들기
	* 일반적 유스케이스: 사용될 거라 예상되는 방법, 결과값 비교로 몇 개 테스트
	* 일반적 오류 케이스: 제대로 동작하지 않을거라 예상되는 부분 테스트
	* 엣지 케이스, 잘못된 아규먼트: nullable, int 범위 테스트 등
장점: 신뢰할 수 있고 리팩터링도 테스트를 통해 쉽게 버그 확인 가능. 수동 테스트보다 확인 시간이 빠르다.
단점: 단위 테스트를 짜는 데 시간이 걸림. 테스트를 활용할 수 있는 아키텍처가 베이스. ‘좋은’ 테스트 짜기가 어렵다.

### 단위 테스트가 필요한 부분
	* 복잡한 부분
	* 계속해서 수정이 일어나고 리팩터링이 일어날 수 있는 부분 
	* 비즈니스 로직
	* 공용 API
	* 문제가 자주 발생하는 부분
	* 프로덕션 버그