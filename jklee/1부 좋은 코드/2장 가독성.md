# 가독성

코틀린은 가독성을 좋게 하는데 목표를 두고 설계됨

## 가독성을 목표로 설계

사용성이 적은 관용구들을 한 문장에 와다다 쓰면 복잡해지고 이해하기 힘듦
과도한 관용구 + 람다 사용은 수정이 어렵고 원하는 결과가 나오지 않을 수도 있다.
짧은 코드 < 익숙한 코드
관용구를 아예 쓰지 말라는 것은 아님. 비용을 지불할만큼 가치가 있다면 사용해도 된다.
복잡한 구조 + 복잡한 구조는 합보다 복잡성이 훨씬 커짐

funA()?.let{ funB() } ?: funC()
funA가 null 이 아니고 funB가 null이면 funB, funC가 모두 호출된다.

if else 가 더 깔끔하다.


### 컨벤션
val abc = "A" { "B" } and "C"
print(abc) 

코드 문제점
* 연산자 의미 무시 (invoke 남용)
* 람다를 마지막 아규먼트로 사용한다.. 위반
* and가 내부 동작과 맞지 않음
* 이미 존재하는 기능을 만듦

## 연산자 오버로드 사용법

의미에 안 맞는 연산자 오버로딩 금지 -> 코틀린은 연산자에 다 함수명이 있다.
but 분명하지 않은 경우 infix, top level fun 활용
but 무시해도 되는 경우 -> DSL 설계 시


## Unit? 을 리턴하지 말라

Unit? 은 Unit, null을 가질 수 있다. 그래서 Boolean(true, false)과 서로 바꿔서 사용할 수 있다.
그러나 Unit? 으로 불린 표현하는건 가독성이 떨어진다. 

## 변수 타입이 명확하지 않은 경우 확실하게 지정하기
`val data = getData()`  보다 `val data: UserData = getData()` 이런식으로 사용한다. 함수를 타고 가서 보는 것 자체가 가독성이 떨어진다는 뜻. But 무조건 지정하란건 아님

## 리시버를 명시적으로 참조
this 같은 명시적 표시를 사용하기
nullable을 사용할때는 apply말고 also, let 사용 -> 리시버 지정하게 돼서 권장
짧게 쓰려하지말고 리시버 사용하기

## 프로퍼티는 동작이 아니라 상태를 나타낸다
프로퍼티는 자바 필드랑 비슷하게 생겼지만 완전 다르다.
게터/세터 제공
코틀린은 디폴트로 캡슐화 되어있고 인터페이스, 오버라이딩, 위임 때도 프로퍼티 사용 가능

```
val Context.preferences: SharedPreferences
	get() = {referenceManager
		.getDefaultSharedPreferences(this)
```
처럼 확장 프로퍼티를 만들수 있다. 함수 대신 쓸 순 있지만 프로퍼티에 많은 계산량 동작은 X, 함수로 따로 구현한다.(상태 표시/설정 목적으로만)
* 연산 비용이 높거나 복잡도 O(1) 초과
* 비즈니스 로직
* 같은 동작을 했을 때 다른 값
* 변환은 toString 처럼 함수로 주로 구성
* 게터에서 상태 변경이 일어나야 하는 경우
반대로 그냥 추출/설정하려고 굳이 함수를 사용하면 안됨

## 이름 있는 아규먼트를 사용하기
Param 에서  joinToString(“,”) 대신 joinToString(separator = “,”) 
처럼 명확하지 않은 argument에 이름을 지정해 줌(또는 변수로 넣어주기)

1. 이름을 기반으로 뭘 나타내는 지 알 수 있음
2. 파라미터 순서와 관계없이 넣을 수 있음

### 특히 써야할 때
* 디폴트 아규먼트 -> addPerson(name: String, age: Int = 20) 같은 함수 사용할 떄
* 같은 타입 파라미터 많을 때 
* 함수 타입 파라미터 있을 때 -> call(before: ()->Unit = {}, after: ()->Unit = {}) 

