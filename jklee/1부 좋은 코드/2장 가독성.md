# 가독성
## 변수 타입이 명확하지 않은 경우 확실하게 지정하기
`val data = getData()`  보다 `val data: UserData = getData()` 이런식으로 사용한다. 함수를 타고 가서 보는 것 자체가 가독성이 떨어진다는 뜻. But 무조건 지정하란건 아님

## 리시버를 명시적으로 참조
this 같은 명시적 표시를 사용하기
nullable을 사용할때는 apply말고 also, let 사용 -> 리시버 지정하게 돼서 권장
짧게 쓰려하지말고 리시버 사용하기

## 프로퍼티는 동작이 아니라 상태를 나타낸다
프로퍼티는 자바 필드랑 비슷하게 생겼지만 완전 다르다.
게터/세터 제공
코틀린은 디폴트로 캡슐화 되어있고 인터페이스, 오버라이딩, 위임 때도 프로퍼티 사용 가능

```
val Context.preferences: SharedPreferences
	get() = {referenceManager
		.getDefaultSharedPreferences(this)
```
처럼 확장 프로퍼티를 만들수 있다. 함수 대신 쓸 순 있지만 프로퍼티에 많은 계산량 동작은 X, 함수로 따로 구현한다.(상태 표시/설정 목적으로만)
* 연산 비용이 높거나 복잡도 O(1) 초과
* 비즈니스 로직
* 같은 동작을 했을 때 다른 값
* 변환은 toString 처럼 함수로 주로 구성
* 게터에서 상태 변경이 일어나야 하는 경우
반대로 그냥 추출/설정하려고 굳이 함수를 사용하면 안됨

## 이름 있는 아규먼트를 사용하기
Param 에서  joinToString(“,”) 대신 joinToString(separator = “,”) 
처럼 명확하지 않은 argument에 이름을 지정해 줌(또는 변수로 넣어주기)

1. 이름을 기반으로 뭘 나타내는 지 알 수 있음
2. 파라미터 순서와 관계없이 넣을 수 있음

### 특히 써야할 때
* 디폴트 아규먼트 -> addPerson(name: String, age: Int = 20) 같은 함수 사용할 떄
* 같은 타입 파라미터 많을 때 
* 함수 타입 파라미터 있을 때 -> call(before: ()->Unit = {}, after: ()->Unit = {}) 

