# 3장 재사용성

### 아이템 19: knowledge 를 반복하여 사용하지 말라

- Don’t repeat yourself ; WET 안티패턴

**knowledge**

- 의도적인 정보 ; 코드, 데이터, 강제 사항들
- (비즈니스) 로직 ; 프로그램이 어떤 식으로 동작하는지, 어떻게 보이는지
- (공통) 알고리즘 ; 원하는 동작을 하기 위한 알고리즘
- 로직은 변하지만, 알고리즘은 쉽게 변하지 않는다.
- knowledge의 반복 하지 말아햐하는 이유
    - 로직은 발전, 플랫폼의 변화 등으로 항상 애자일하게 변화 함
    - 유지 보수가 힘들어짐
    - 확장성과 안정성을 해침
- 반면 knowledge의 반복을 줄이면 안 되는 경우
    - 단일 책임 원칙 (SRP)에 의거하여 판단할 수 있음
    - 코드를 추출하면 안되는 경우
        - 반복처럼 보이나 실질적으로는 다른 경우
            - 안드로이드 gradle을 하나로 동기화 시키는 경우는 말이 안됨
    - “함께 변경될 가능성이 높은가? 따로 변경될 가능성이 높은가?”
        - 코드를 추출하는 이유는 변경을 쉽게 만들기 위함이어야 함
        - 비즈니스 로직이 다른 곳에서 왔는지 확인
            - 다른 곳에서 왔다면 독립적으로 변경될 가능성이 있다.

**단일 책임 원칙 (SRP)**

- 클래스를 변경하는 이유는 단 한가지여야 한다.
- 두 액터가 같은 클래스를 변경하면 안된다.
    - 액터 ; 변화를 만드는 존재; 서로의 업무, 분야를 잘 모르는 개발자들
- 일반적으로 private 함수는 두 가지 이상의 역학을 하지 않는 관습
- 파일, 클래스 자체를 분리하라

### 아이템 20: 일반적인 알고리즘을 반복해서 구현하지 말라

**알고리즘**

- 일반적인 알고리즘은 표준 라이브러리를 공부하여 사용하라
    - 개발자가 따로 구현한 알고리즘과는 달리 표준 라이브러리를  사용하면 별도로 구현을 보지 않아도 동작이 뭔지 알 수 있음
- 특수 알고리즘이 필요한 경우, 확장 함수로 정의하라
    - 타입 제한이 가능하다
    - 가독성 측면에서, 파라미터로 값을 받는 것보다 확장 리시버 (확장 함수)로 값을 받는게 더 좋다.
    - 특정 타입에 대해 자동 완성 기능이 지원되므로, 사용성이 좋아진다. (파일이나 클래스 이름을 몰라도 확장 함수 단위로 접근 가능)

### 아이템 21: 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라

- 위임 ; **어떤 기능을 자신이 수행하지 않고 다른 객체가 수행하도록 하는 패턴**
- 코틀린 by
    - 위임 패턴 구현시에 필요한 Wrapper 메소드 작성 보일러 플레이트를 줄여주는 코틀린 키워드
- 프로퍼티 위임은 다른 객체의 메서드 를 활용해서 프로퍼티의 접근자(게터와 세터)를 만드는 방식
- lazy, observable 을 사용하라
    - lazy ; 처음 사용하는 요청이 들어올 때 초기화되는 프로퍼티
        - 해당 변수가 호출되는 시점에 초기화
        
        <aside>
        📌 `lateinit` vs `by lazy`
        
        </aside>
        
        - lazy 프로퍼티 패턴을 사용하면, observable 패턴을 쉽게 구현 가능
            - observable ; 변화가 있을 때 이를 감지
- 프로퍼티 위임은 프로퍼티 패턴을 추출하는 일반적인 방법이다.
- 프로퍼티 위임은 프로퍼티에 대한 다양한 조작을 가능하게 한다.

### 아이템 22: 일반적인 알고리즘을 구현할 때 제네릭을 사용하라

- 타입 파라미터 ; 함수에 타입 전달 가능
- 제네릭 함수 ; 타입 파라미터를 가지는 함수
- 타입을 명시하여, 컴파일 단에서 검사 가능 (안정성 향상), 개발자의 가독성 향상
    - List<String> 에서 값을 꺼내면 String 일거라는 보장 가능
- 타입 파라미터를 사용할 때, 타입을 제한하여 (서브 타입을 사용하여) 타입 세이프하게 코딩하세요
    - 서브타입 ; Iterable, Comparable, Any

### 아이템 23: 타입 파라미터의 새도잉을 피하라

- 타입 파라미터의 새도잉 ; 바깥 스코프에 있는 프로퍼티와 현재 스코프에 있는 프로퍼티가 같은 이름을 사용하여서, 바깥 스코프에 있는 프로퍼티가 가리는 경우
    - 대상 ; 람다, 클래스 타입 파라미터, 함수 타입 파라미터
    - 람다 같은 경우에는 에러는 발생하지 않으나, IDE 상에서 워닝을 줌

### 아이템 24: 제네릭 타입과 variance 한정자를 활용하라

TBD 

### 아이템 25: 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라

- 카카오페이 예시
    - 카카오톡 앱과 카카오페이 앱의 기능의 교집합은 공통 모듈화