# 1장 안정성

- 코틀린은 정말 안전한 언어지만, 정말로 안전하게 사용하려면 개발자가 뒷받침을 해야 한다.
    - 1장의 목적은 **오류가 덜 발생하는 코드를 만드는 것**

## 아이템 1 가변성을 제한하라

### 가변성을 왜 제한해야 하나요?

- 프로그램을 이해하고 디버그하기 힘들어짐
    - 상태를 갖는 부분의 관계를 이해해야함
    - 상태 변경을 추적해야함
- 코드 실행 추론이 어려워짐
    - 시점에 따라 값이 바뀔 수도 있고, 그 값을 알아야만 실행을 추론할 수 있음
    - 한 시점에 확인한 값이 동일하다고 보장할 수도 없음
- 멀티스레드 환경에서 동기화는 필수이므로, 가변성으로 인한 영향 범위를 최소화 해야함
    - 애초에 멀티스레드 환경에서 동기화를 잘 구현하는건 굉장히 어려운 일임
    - 허나 가변 지점이 많다면, 동기화 구현은 더 어려워질 것 임
    - 따라서 가변 지점을 줄일 수록 좋음
- 테스트가 어려워짐.
    - 가변성에 대한 모든 경우를 테스트 해야함. 변경이 많을 수록 더 많은 조합을 테스트 해야함을 의미함.
- 상태 변경으로 인한 영향 범위가 있을 수 있음. 이런 경우엔 다른 부분들에게 상태 변경을 전파 시켜야하므로, 비효율적이게 됨
- 심지어 가변성을 엄격하게 제한하는 프로그래밍 언어도 있음 (= 순수 함수형 언어)
    - ex. 하스켈

### 코틀린에서 가변성 제한하기

**읽기 전용 프로퍼티 (val)** 

- value 임. var의 variable과 구분
- var 프로퍼티를 get() 해오는 val 프로퍼티는 var 프로퍼티가 변할 때 변할수 있음
    - 값을 추출할 때마다, 사용자 정의 getter가 호출되므로, 아래와 같이 동작함
    
    ```kotlin
    var name: String = "sery"
    var surname: String = "270"
    val fullName: String
    	get() = "$name + $surname"
    
    fun main() {
    	println(fullName) // sery270
    	name = "seran"
    	println(fullName) // seran270
    ```
    
- 값을 추출할 때마다, 사용자 정의 getter가 호출됨
    
    ```kotlin
    
    fun calculated: Int { print("Calculating... ") return 42 }
    
    val fizz = calculate() // -> calculate() 단순 리턴 값을 할당 받음 
    val buzz
    	get() = calculate() // -> 값을 가져올 때마다 calculate() 호출하도록 정의함 
    
    fun main() {
    		print(fizz) // 42 
    		print(fizz) // 42 
    		print(buzz) // Calculating... 42 
    		print(buzz) // Calculating... 42
     }
    ```
    
- 코드를 보았듯이, 읽기 전용 프로퍼티 val의 값은 변경될 수 있기는 하지만, 프로퍼티 레퍼런스 자체를 변경할 수는 없으므로 동기화 문제 등을 줄일 수 있음
    - val과 스마트 캐스트
        
        ```kotlin
        val name: String? = "Marton" 
        val surname: String = "Braun"
        
        val fullName: String?
        	get() = name?.let { “$it $surname" }
        val fullName2: String? = name?.let { "$it $surname" }
        
        fun main() {
        	if (fullName != null) { 
        		println(fullName.length) // 오류 
        	}
        	if (fullName2 != null) { 
        		printin(fullName2.length) // Marton Braun 
        	}
        }
        ```
        
        - 세리 부연 설명
            - fullName
                - **fullName은 getter 정의**이므로, 값이 시점에 따라 바뀔 수 있음.
                - if 문으로 null 체크를 했더라도, **동시성 이슈로 null이 될 수 있음**
                - 따라서 스마트 캐스팅 되지 못해, 여전히 String? 타입이므로, length 호출 못함
            - fullName2
                - fullName2는 선언과 동시에 초기화 됨. 사용자 getter를 갖지 않음.
                - 따라서 값이 변할 수 없으므로, if 문으로 null 체크를 한 이후에 값이 변할 여지가 없음.
                - 따라서 String 타입으로 스마트 캐스팅 되어, length 호출 가능

<aside>
☺️ **JUMP TO** 아이템 16: 프로퍼티는 동작이 아니라 상태를 나타내야 한다

</aside>

**가변 컬렉션(**mutable)**과 읽기 전용 컬렉션(**immutable**) 구분하기**

- immutable 컬렉션은 mutable 컬렉션을 상속 받았다.
- 컬렉션 다운 캐스팅은 하면 안된다
    - immutable 컬렉션을 mutable 컬렉션으로 다운 캐스팅 하면 안된다
- 다운 캐스팅 대신, copy() 를 활용하여 mmutable 컬렉션을 mutable 컬렉션으로 만들어야한다.

**데이터 클래스의 copy**

- immutable 객체는 동시성에 강하다
- immutable 객체는 set과 map의 키로 사용 가능하다.
    - 해시 테이블은 값 기반으로 버킷을 결정하기 때문에, 값 변경이 일어나면 키가 바뀌는 셈이다
- **immutable 객체를 사용하면서 값 변경이 필요할 때엔, 데이터 클래스의 copy를 사용하여, immutable 특성을 보장하면서 값을 변경할 수 있다.**

- 상태를 변경할 수 있는 불필요한 방법은 만들지 않는 것이 좋음
- immutable 프로퍼티에 mutable 컬렉션을 사용하는 것 보다mutable 프로퍼티에 **immutable 컬렉션을 넣어 사용**하는 것이 좋음
    - 멀티 스레드 안정성이 더 좋음
    - 사용자 정의 세터를 통해 변경 추적 가능
    
    ```kotlin
    val listl: MutableList<Int> = mutableListOf() 
    var list2: List<Int> = listOf()
    ```
    
- 상태를 나타내는 mutable 객체를 외부에 노출하는 것은 굉장히 위험

- var보다는 val을 사용하는 것이 좋습니다.
- mutable 프로퍼티보다는 immutable 프로퍼티를 사용하는 것이 좋습니다.
- mutable 객체와 클래스보다는 immutable 객체와 클래스를 사용하는 것이 좋습니다.
- 변경이 필요한 대상을 만들어야 한다면, immutable 데이터 클래스로 만들고 copy를 활용하는 것이 좋습니다.
- 컬렉션에 상태를 저장해야 한다면, mutable 컬렉션보다는 읽기 전용 컬렉션을 사용하는 것이 좋습니다.
- 변이지점을 적절하게 설계하고, 불필요한 변이지점은 만들지 않는 것이 좋습니다.
- mutable 객체를 외부에 노출하지 않는 것이 좋습니다.

### 아이템 2 변수의 스코프를 최소화하라

- 프로퍼티보다는 지역 변수를 사용하는 것이 좋습니다.
- 최대한 좁은 스코프를 갖게 변수를 사용합니다. 예를 들어 반복문 내부에서만 변수가 사용된다면, 변수를 반복문 내부에 작성하는 것이 좋습니다.
    - mutable 프로퍼티는 좁은 스코프에 걸쳐 있을수록, 그 변경을 추적하는 것이 쉽다.
- 변수를 정의할 때 초기화되는 것이 좋습니다
- 여러 프로퍼티를 한꺼번에 설정해야 하는 경우에는 구조분해 선언(destmcturing declaration)을 활용하는 것이 좋습니다.
    
    ```kotlin
    val (description, color) = when {
    	degrees < 5 -> "cold" to Color.BLUE 
    	degrees < 23 -> "mild" to Color.YELLOW
    	else -> '’hot” to Color.RED 
    }
    ```
    
- 람다에서 변수를 캡처하므로, 스코프 설정시 주의해야한다.
    
    ```kotlin
    // Sequence 로 리펙토링한 코드

    val primes: Sequence<Int> = sequence {
        var numbers = generateSequence(2) { it + 1 }
        while (true) {
            val prime = numbers.first() // while 문 안에서만 쓰이는 변수 prime이 외부 스코프에 선언
            yield(prime) // suspend point!
            numbers = numbers.drop(1).filter { it % prime != 0 }
            print(numbers.toList())
        }
    }

    print(primes.take(2).toList())


    // Sequence 로 리펙토링 && 스코프를 잘못 사용하여 의도치 않은 결과를 초래하는 코드
    //

    // 📌 TIL 1. Sequence vs Iterable
    // Sequence : 각각 하나의 element 에 대해 모든 단계를 수행한다.
    // filter, drop과 같은 중간 연산에서는 바로 연산을 수행하지 않고 종단 연산인 first를 만날때까지 연산을 누적해서 대기
    //
    // Iterable : 전체 collection 에 대해 각 단계의 수행을 완료하고 다음 단계로 넘어간다.
    // filter, drop, first 만나는 즉시 실행

    // 📌 TIL 2. lambda capturing
    // 람다 스코프에서 외부의 변수 사용

    val primes: Sequence<Int> = sequence {
        var numbers = generateSequence(2) { it + 1 }
        var prime: Int
        while (true) {
            prime = numbers.first() // while 문 안에서만 쓰이는 변수 prime이 외부 스코프에 선언
            yield(prime) // suspend point!
            numbers = numbers.drop(1).filter { it % prime != 0 }
            print(numbers.toList())
        }
    }

    print(primes.take(2).toList())
    - 세리 부연 설명 ) lamda capturing
        - 람다 본문 블럭 내에서 외부 함수의 로컬 변수나 글로벌 변수등을 사용
        - *자바와 달리 코틀린 람다 안에서는 final 변수가 아닌 본래의 변수에 접근이 가능하며, 변경도 가능*
    ```

### 아이템 6 사용자 정의 오류보다는 표준 오류를 사용하라

- 직접 오류를 정의하는 것보다는 최대한 표준 라이브러리의 오류를 사용하는 것이 가독성 측면에서 좋다.

### 아이템 7 결과 부족이 발생할 경우 null과 Failure를 사용하라

- 예외와 실패(오류)를 구분하라
    - 예외 → 예측하기 어려운 범위의 오류
        - throw
    - 오류 → 충분히 예측 가능한 범위의 오류
        - null, Result (Failure, Success)
            - sealed class 인 Result 클래스
                - when 식에서 활용도가 높음
            - null vs Failure(Result)
                - Failure는 null과 달리 처리할 때 필요한 정보를 가질 수 있음
- 예)
    - get → 예외로 처리
        - 오류를 예측할 수 없는 경우, IndexOutOfBoundsException을 리턴
    - getOrNull → 오류로 처리
        - out of range 오류가 발생할 수 있다고 충분히 예측한 경우에 사용, null을 리턴
            - null이 리턴될 수 있다고 알려, nullable 하게 대처 가능

### 아이템 8 적절하게 null을 처리하라