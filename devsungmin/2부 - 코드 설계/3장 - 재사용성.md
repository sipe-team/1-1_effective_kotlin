### 3장 - 재사용성

---

### [아이템 19 - knowledge를 반복하여 사용하지 말라]

> 프로젝트에서 이미 있던 코드를 복사해서 붙여넣고 있다면, 무언가가 잘못된 것이다.

- <<실용주의 프로그래머>>라는 책에서는 'Don't Repeat Yourself' 라는 규착을 DRY규칙 이라고 표현하고 있다.
- WET안티패턴이라는 이름으로 알 고 있는 사람도 있을텐데 DRY 또한 SSOT라는 이름으로도 알려져 있다.

**[knowledge]**

- 프로그래밍에서 knowledge는 `의도적인 정보`를 뜻한다.
- 상속을 하는데 특정 메서드를 override하지 않게 강제 한다는 것은 해당 메서드가 슈퍼클래스와 동일하게 동작하기 원한다는 것을 의미한다.
- 이처럼 코드에서 정의한 모든 것이 knowledge이다.
- 이것은 종류는 다양하며, 알고리즘의 작동 방식 / UI의 형태 / 우리가 원하는 결과 등이 모두 의도적인 정보이며, knowledge이다.
- 우리 프로그램에서 중요한 knowledge를 크게 두가지 뽑자면
  - 로직 : 프로그램이 어떤식으로 동작하는지와 프로그램이 어떻게 보이는지
  - 공통 알고리즘 : 원하는 동작을 하기 위한 알고리즘
- 둘의 가장 큰 치이는 시간에 따른 변화이다.
- 비즈니스 로직은 시간이 지나면서 계속 변하지만 공통 알고리즘은 한번 정의된 이후에는 크게 변하지 않는다.

**[모든 것은 변화한다]**

- 프로그래미에서 유일하게 유지 되는 것은 '변화한다는 속성'이라는 말이 있다.
- 많은 프로젝트들은 10년 또는 20년 동안 유지되며 유명한 애플리케이션 및 사이트는 변하지 않는 곳도 있으며, 기술 뿐만 아니라 언어도 빠른 속도로 변화 한다.
- 변화는 우리가 예상하지 못한 곳에서 일어난다.

**[단일 책임 원칙]**

- 코드를 추출해도 되는 지 확인하는 원칙으로 SOLID 원칙 중 하나인 단일 책임 원칙이 있다.
- 단일 책임 원칙이란 `클래스를 변경하는 이유는 단 한가지여야 한다`라는 의미로 '두 actor가 같은 클래스를 변경하는 일은 없어야 한다.'로 `<<클린 아키텍처>>` 에서는 비유를 하였는데, 여기서 actor는 변화를 만들어 내는 존재를 의미한다.
  - actor는 서로의 업무와 분야에 대해서는 잘 모르는 개발자를 의미힌다.
- 서로 다른 곳에서 사용하는 knowledge는 독립적으로 변경할 가능성이 많아서 비슷하더라도 완전히 다른 knowledge로 취급하는 것이 좋다.

---

### [아이템 20 - 일반적인 알고리즘을 반복해서 구현하지 말라]

- 많은 개발자는 같은 알고리즘을 여러 번 반복해서 구현한다.
- 하지만 대부분의 언어는 간단한 연산이나 수식같은 경우는 라이브러리나 함수를 사용해서 제공을 하고 있는데, 이것을 활용하면 코드가 짧아 진다는 장점도 있지만 다른 장점들도 있다.
  - 코드 작성 속도가 빨라지며, 호출을 한 번 하는 것이 알고리즘을 만드는 것보다 빠르다.
  - 구현을 따로 읽지 않아도 함수의 이름만으로도 어떤 역할을 하는지 확실하게 알 수 있다.
  - 직접 구현 할 때 발생 할 수 있는 실수를 줄 일 수 있다.
  - 제작자들이 한번만 최적화 하면 이러한 함수를 활용하는 모든 곳에서 최적화 혜택을 받을 수 있다.

---

### [아이템 21 - 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라]

- 코틀린은 코드 재사용과 관련해서 프로퍼티 위임 이라는 기능을 제공한다.
- 프로퍼티 위임을 사용하면 일반적인 프로퍼티의 행위를 추출해서 재사용 할 수 있다.
- 대표적으로 처음 사용하는 요청이 들어올 때 초기화를 하는 지연 프로퍼티(lazy property)가 있다.
- 프로퍼티 위임을 사용하면, 변화가 있을 때 이것을 감지하는 observale 패턴을 쉽게 만들 수 있다.

---

### [아이템 22 - 일반적인 알고리즘을 구현할 때 제네릭을 사용하라]

- aguments로 함수에 값을 전달하는 것 처럼 type aguments를 사용하면 함수에 타입을 전달 할 수 있다.
- type grguments를 사용하는 함수를 제네릭 함수라고 한다.
- 제네릭은 기본적으로 List<String> 또는 Set<Uer>처럼 구체적인 타입으로 컬렉션을 만들 수 있게 클래스와 인터페이스에 도입된 기능이다.

**[제네릭 제한]**

- 타입 파라미터의 중요한 기능 중 하나는 구체적인 타입의 서브 타입만 사용하게 타입을 제한하는 것이다.

---

### [아이템 23 - 타입 파라미터의 섀도잉을 피하라]

- 프로퍼티와 파라미터는 같은 이름을 가질 수 있다.
- 이렇게 되면 지역 파리미터가 외부 스코프에 잇는 프로퍼티를 가리게 되는데, 이것을 `shadowing`이라고 부른다.

```kotlin
class Forest(val name: String) {
  fun addTree(name: String) {
    // ...
  }
}
```

- 이런 현상은 클래스 타입 파라미터와 함수 타입 파라미터 사이에서도 발생한다.

  - 특히 개발자가 제네릭을 제대로 이해하지 못할 때 이와 같은 문제가 발생하며, 심각한 문제가 될 수 있고, 심하면 문제를 스스로 찾아내기 힘들다.

    ```kotlin
    interface Tree
    class Birch: Tree
    class Spruce: Tree
    
    class Forest<T: Tree> {
      fun <T: Tree> addTree(tree: T) {
        // ...
      }
    }
    ```

---

### [아이템24 - 제네릭 타입과 variance 한정자를 활용하라] -> 해당 아이템은 추후에 한번 더 읽어보자!

- 제네릭 타입에서 관련성으 원한다면 `out` 또는 `in`을 붙여서 사용한다.
- `out`은 타입 파라미터를 `covariant`로 만든다.

**[함수 타입]**

- 함수 타입은 파라미터 유형과 리턴타입에 따라서 서로 어떤 관계를 갖는다.
- 코틀린 함수 타입의 모든 파라미터 타입은 `contravariant`이다.
  
  ![코틀린 타입 계층](https://github.com/sipe-team/1-1_effective_kotlin/blob/week4-sungmin/devsungmin/2%EB%B6%80%20-%20%EC%BD%94%EB%93%9C%20%EC%84%A4%EA%B3%84/assets/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-08-06%20%EC%98%A4%ED%9B%84%2010.51.00.png)

**[`variance`한정자의 위치]**

- `variance` 한정자의 위치는 크게 두 위치에서 사용 할 수 있다

  - 선언부분

    - 일반적으로 이 위치에 사용한다.

    ```kotlin
    // 선언 쪽의 variance 한정자
    class Box<out T>(val value: T)
    val boxStr: Box<String> = Box("Str")
    val boxAny: Box<Any> = boxStr
    ```

  - 클래스와 인터페이스를 활용하는 위치

    - 특정한 변수에만 `variance`한정자가 적용됨

      ``` kotlin
      class Box<T>(val value: T)
      val boxStr: Box<String> = Box("Str")
      // 사용하는 쪽의 variance 한정자
      val boxAny: Box<out Any> = boxStr
      ```

- 타입 파라미터의 기본적인 `variance`의 동작은 `invariant`이다.

- 코틀린에서 List와 Set의 타입 파라미터는 `covariant(out 한정자)`이다.

- 코틀린에서의 타입 파라미터의 기본적인 variance동작은 `invariant `이다.

---

### [아이템 25 - 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라]

- 기업은 일반적으로 둘 이상의 플랫폼을 대상으로 제품을 만들고 있으며, 대부분의 기업이 여러 플랫폼을 운영하고 있다.
- 공통 모듈울 정의할 수 있다는 것은 라이브러리에 있어서 강력한 도구이며, 플랫폼에 크게 의존하지 않는 다는 점이 있다.