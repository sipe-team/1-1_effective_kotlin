### 2장 - 가독성

---

- 코틀린은 간결성을 목표로 설계된 프로그래밍 언어가 아닌 **가독성**을 좋게하는 데 목표를 두고 설계된 프로그래밍 언어이다.

### [아이템 11 - 가독성을 목표로 설계하라]

- 프로그래밍은 쓰기보다 읽기가 중요하다

- 항상 가독성을 생각하면서 코드를 작성해야한다.

  **[인식 부하 감소]**

  > 아래 코드를 보면 코드를 보자마자 바로 이해할 수 있는 코드는 구현 A이다.
  >
  > 하지만 코틀린이 익숙해진 지금은 구현 B에 대한 코드도 쉽게 읽힌다.
  >
  > 가독성은 내 코드를 누군가 볼 떄 빠른 시간 내에 코드 내용을 이해할 수 있도록 구현해야한다.

  ```kotlin
  // 구현 A
  if(person != null && person.isAdult) {
    view.showPerson(person)
  } else {
    view.showError(0)
  }
  
  // 구현 B
  person?.takeIf { it.isAdult }?.let{view::showPerson}?: view.showError()
  ```

  >  takeIf => 람다에 제공된 조건 식의 결과에 따라 Boolean타입으로 반환함
  >
  >  lef => 함수의 인자로 전달된 람다를 실행 하고 결과를 반환함

  - 가독성이란 코드를 읽고 얼마나 빠르게 이해할 수 있는지를 의미한다.
  - **숙련된 개발자만을 위한 코드는 좋은 코드가 아니다.** -> 구현 A처럼 코틀린 초보자도 코드만을 보고 이해할 수 있도록 구현하는 것이 좋은 코드이다.
  - 사용 빈도가 적은 관용구는 코드를 복잡하게 만들며, 한 문장 내부에 조합해서 사용하면 복잡성은 훨씬 더 빠르게 증가한다.
  - 구현 B처럼 초보자에게 익숙하지 않는 구조를 사용하면 잘못된 동작을 코드를 보면서 확인하기 어렵다.
  - 기본적으로 인지 부하를 줄이는 방향으로 코드를 작성해야한다.

  

  **[극단적이 되지 않기]** -> 솔직히 책 만든 사람의 의도를 이해못하겠다...  뭐 어쩌란거야 짜증나게 하지마 글쓴이 ㅂㄷㅂㄷ

  - `let`은 좋은 코드를 만들기 위해서 다양하게 활용되고 있는 코드이다.
    - `nullable`한 가변 프로퍼티가 있고 null이 아닐때 어떠한 작업을 수행해야하는 경우
    - 연산을 augments 처리 후 이동 시킬 때
    - 데코레이터를 사용하여 객체를 랩 할 때 ??

---

### [아이템 12 - 연산자 오버로드를 할 때는 의미에 맞게 사용하라]

- 연산자 오버로딩은 굉장히 강력한 기능이지만, 잘못 사용하면 굉장히 위험하다

- 팩토리얼을 구하는 함수를 예로 설명을 해보자!

- 우리는 수학시간에 팩토리얼을 구하는 기호를 `!`을 사용하여 표기하는 것으로 배웠다.

  > 6! = 6 * 5 * 4 * 3 * 2 * 1

해당 기호를 코틀린의 확장 함수 기능을 사용하여 숫자형 타입에 `!`을 붙이면 팩토리얼 계산이 되도록 구현을 해보자

``` kotlin
fun Int.factorial(): Int = (1..this).product()

fun Iterable<Int>.product(): Int = fold(1) { acc, i -> acc * i }


print(10 * 6.factorial()) // 7200
```

이러한 코드를 연산자 오버로딩을 활용하면 다음과 나타낼 수 있다.

> 코틀린에서 연산자 오버로딩은 **`operator`**라는 키워드를 사용하여 쓴다.

``` kotlin
operator fun Int.not() = factorial()

print(10 * !6) // 7200
```

- 과연 이 코드는 좋은 코드일까...

- 아니다 코틀린에서 `!`을 붙이면 `not`을 의미하며, 코드를 이렇게 작성한다면 연산자 오버로딩 코드를 못본 사람이라면 `10 *!6`이라는 코드를 `6이 아니다`로 오해를 할 수 있다.

- 따라서 해당 코드를 만약 사용하다면 아래와 같은 코드로 사용해야한다.

  ```kotlin
  print(10 * 6.not())
  ```

- 과연 이게 최선일까 🤔 누가 이것을 보고 팩토리얼 코드라고 생각을 할까...

- 작정하고 내부 코드를 보는 사람이 아니라면 해당 코드만으로는 연산의 결과가 `7200`라는 값이 왜 나오는지 알 수 없을 것이다.

- 코틀린의 모든 연산자는 구체적인 이름을 가진 함수에 대한 별칭이 있고, 연산자 대신 함수로 호출 할 수 있다.

  > +a : a.unaryPlus()
  >
  > !a : a.not()
  >
  > a+b: a.plus(b)
  >
  > a-b: a.minus(b)

- 즉, 연산자의 본래의 의미가 있기 때문에 이것을 벗어나도록 오버로딩을 하게 되면 코드를 보는 개발자 입장에서는 많은 오해의 소지가 발생할 수 있고 더 나아가 오류가 발생하였을 때 디버깅을 하는 과정에서 많은 어려움이 있을 수 있다.

**[분명하지 않는 경우]**

- 하지만 코드를 구현하다보면 내가 오버로딩한 연산자가 관례에 충족하는지 확실 하지 않을 때가 있다.
- 의미가 명확하지 않는다면 infix를 사용하여 확장 함수를 사용하는 것이 좋다.

---

### [아이템13 - Unit?을 리턴하지 말라]

```kotlin
// code 1
fun keyIsCorrect(kehy: String): Boolean = //

if(!keyIsCorrect(key)) return


// code 2
fun verifyKey(key: String): Unit? = //

verifyKey(key) ?: return
```

- code 1의 코드를 code 2처럼 사용하여 Boolean과 Unit?타입은 서로 바꿔서 사용할 수 있다.
- 하지만 code 2에 대한 코드를 읽을 때는 쉽게 읽지 못할 뿐더러 Unit?으로 처리하는 것은 오해의 소지가 있고, 예측하기 어려운 오류를 만들 수 있다.
- 따라서 이런경우에는 Unit으로 표현하는 것 보단 Boolean을 사용하여 변경하는 것이 좋다.

---

### [아이템 14 - 변수 타입이 명확하지 않은 경우 확실하게 지정하라]

- 코틀린의 경우 코드상에서 타입을 지정하지 않아도 언어적으로 타입을 지정하는 수준 높은 타입 추론 시스템을 가지고 있다.

- 이는 개발 시간을 줄여주며, 변수의 값이 명확 할 때 코드가 짧아지고 가독성이 크게 향상 된다.

- 하지만 아래와 같은 경우는 명확하지 않아 가독성을 위해서 타입을 명확하게 적어 주는 것이 좋다.

  ```kotlin
  // bad case
  val data = getSomeData()
  
  // good case
  val data: UserData = getSomeData()
  ```

  - 물론 해당 함수를 찾아가 타입을 확인할 수 있지만 이는 가독성이 떨어진다.

- **`코드를 설계 할 때는 읽는 사람에게 중요한 정보를 숨겨서는 안된다`**

- 안전을 위해서 타입을 지정하는 것이 좋다.

---

### [아이템 15 - 리시버를 명시적으로 참조하라]

- 코드는 명시적으로 긴 코드를 사용할 떄가 있다.
- 스코프 내부에 둘 이상의 리시버가 있는 경우 리시버를 명시적으로 나타내는 것이 좋다.

> DSL(Domain Specific Language)??
>
> 도메인 특정 언어로 특정 도메인에 국한해 사용된다.
>
> 홈.. DSL을 사용안해봐서 DSL 마커부분은 조금 이해가 안간다..

---

### [아이템 16 - 프로퍼티는 동작이 아니라 상태를 나타내야 한다]

- 코틀린의 프로퍼티는 자바의 필드와 비슷해보이지만 서로 완전 다른 개념이다.

  ``` kotlin
  // kotlin
  var nameL String? = null
  
  // java
  String name = null;
  ```

- 코드로 보면 둘 다 데이터를 저장한다는 점은 같지만 프로퍼티에는 더 많은 기능이 있다.

- 기본적으로 사용자 정의 setter와 getter를 가질 수 있다.

  ```kotlin
  var name: String? = null
  		get() = field?.toUpperCase()
  		set(value) {
        if(!value.isNullOrBlank()) {
          field = value
        }
      }
  ```

  - 이 코드에서 field라는 식별자를 확인 할 수 있는데, 이는 프로퍼티의 데이터를 저장해두는 백킹 필드(backing field)에 대한 레퍼런스이다.
  - 이런 백킹 필드는 setter와 getter의 디폴트 구현에 사용되므로, 따로 만들지 않아도 디폴드로 생성된다.
  - 또한 `val`로 선언된 프로퍼티의 경우는 field가 만들어지지 않는다.
  - `var`을 사용해서 만든 프로퍼티는 getter와 setter를 정의 할 수 있으며, 이런 프로퍼티를 파생 프로퍼티(derived propertty)라고 부르며, 자주 사용한다.

- 코틀린은 인터페이스에서도 프로퍼티를 정의할 수 있다.

  ``` kotlin
  interface Person {
    val name: String
  }
  ```

  - 이런 경우 getter를 가지고 잇으며 override하여 사용 할 수 있다.

---

### [아이템 17 - 이름있는 아규먼트를 사용하라]

- 코드에서 파라미터의 의미가 명확하지 않은 경우가 있다.
- 의미가 명확하지 않는 파라미터를 사용하게되면 이를 직접 지정해서 명확하게 만들어 줄 수 있다.

[이름 있는 아규먼트는 언제 사용해야할까?]

- 이름있는 아규먼트를 사용하게되면 코드가 길어지지만 이름을 기반으로 값이 무엇인지 나타내는지 알 수 있으며, 파라미터 입력 순서와 상관 없으므로 안전하다,

- 야규먼트 이름은 함수를 사용하는 개발자 뿐만 아니라 코드를 읽는 다른 사람들에게도 중요한 정보이다.

- 디폴트 아규먼트의 경우 디폴트 아규먼트를 가지고 있는 경우 항상 이름을 붙여서 사용하는 것이 좋다

- 같은 타입의 파라미터가 많은 경우 이름 있는 아규먼트를 사용하는 것이 좋다.

  ``` kotlin
  fun sendEmail(to: String, message: String) { ... }
  
  // using same agument type
  sendEmail(
    to = "test@gmail.com",
    message = "hello"
  )
  ```

[함수 타입 파라미터]

- 함수 타입 파라미터의 경우 조금 특별하게 다루어야 하며 마지막 위치에 배치하는 것이 좋다.
- 모든 함수 타입 아규먼트의 경우 이름 있는 아규먼트를 사용 하는 것이 이해하기 쉽다.

---

### [아이템 18 - 코딩 컨벤션을 지켜라]

- 코틀린은 굉장히 잘 정리된 코딩 컨벤션을 갖고 있다.
- 컨벤션을 지켜주게 되면 다음과 같은 장점을 가지고 있다.
  - 어떤 프로젝트를 접해도 쉽게 이해 할 수 있다.
  - 다른 개발자도 프로젝트 코드를 쉽게 이해 할 수 있다.
  - 다른 개발자도 코드의 작동 방식을 쉽게 추측할 수 있다.
  - 코드를 병합하고, 코드 일부를 다른 코드로 이동하는 것이 쉽다.